{"version":3,"sources":["../../../projects/ngx-uploader/src/lib/interfaces.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/ngx-uploader/src/lib/ngx-uploader.class.ts","../../../projects/ngx-uploader/src/lib/ng-file-drop.directive.ts","../../../projects/ngx-uploader/src/lib/ng-file-select.directive.ts","../../../projects/ngx-uploader/src/lib/ngx-uploader.module.ts"],"names":["UploadStatus","Object","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","humanizeBytes","bytes","Math","floor","log","parseFloat","pow","toFixed","NgUploaderService","concurrency","contentTypes","maxUploads","maxFileSize","_this","this","Number","POSITIVE_INFINITY","queue","serviceEvents","EventEmitter","uploadScheduler","Subject","subs","pipe","mergeMap","upload","startUpload","subscribe","uploadOutput","emit","prototype","handleFiles","incomingFiles","allowedIncomingFiles","reduce","acc","checkFile","futureQueueLength","length","isContentTypeAllowed","type","isFileSizeAllowed","size","concat","rejectedFile","makeUploadFile","file","_a","apply","arguments","__spread","map","uploadFile","initInputEvents","input","event","uploadFileIndex","findIndex","filter","progress","status","Queue","forEach","id_1","id","sub","unsubscribe","fileIndex","Cancelled","find","splice","Observable","observer","finalize","closed","complete","output","err","url","method","data","headers","xhr","XMLHttpRequest","time","Date","getTime","progressStartTime","startTime","speed","eta","addEventListener","lengthComputable","percentage","round","loaded","total","diff","ceil","Uploading","speedHuman","endTime","etaHuman","secondsToHuman","onreadystatechange","readyState","DONE","speedAverage","Done","responseStatus","response","JSON","parse","responseHeaders","parseResponseHeaders","getAllResponseHeaders","open","withCredentials","uploadFile_1","nativeFile","uploadIndex","outFile","keys","key","setRequestHeader","bodyToSend","includeWebKitFormBoundary","form","append","fieldName","name","send","abort","sec","toISOString","substr","generateId","random","toString","substring","setContentTypes","Array","undefined","allContentTypesAllowed","mimetype","fileSize","index","FormData","lastModifiedDate","lastModified","httpHeaders","split","x","NgFileDropDirective","elementRef","stopEvent","stopPropagation","preventDefault","ngOnInit","_sub","options","allowedContentTypes","el","nativeElement","uploadInput","ngOnDestroy","onDrop","dataTransfer","files","onDragOver","dropEffect","onDragLeave","Directive","args","selector","ElementRef","Input","Output","HostListener","NgFileSelectDirective","fileListener","removeEventListener","NgModule","declarations","exports"],"mappings":"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","sourcesContent":["import { Subscription } from 'rxjs';\r\n\r\nexport interface UploaderOptions {\r\n  concurrency: number;\r\n  allowedContentTypes?: string[];\r\n  maxUploads?: number;\r\n  maxFileSize?: number;\r\n}\r\n\r\nexport interface BlobFile extends Blob {\r\n  name: string;\r\n}\r\n\r\nexport enum UploadStatus {\r\n  Queue,\r\n  Uploading,\r\n  Done,\r\n  Cancelled\r\n}\r\n\r\nexport interface UploadProgress {\r\n  status: UploadStatus;\r\n  data?: {\r\n    percentage: number;\r\n    speed: number;\r\n    speedHuman: string;\r\n    startTime: number | null;\r\n    endTime: number | null;\r\n    eta: number | null;\r\n    etaHuman: string | null;\r\n  };\r\n}\r\n\r\nexport interface UploadFile {\r\n  id: string;\r\n  fileIndex: number;\r\n  lastModifiedDate: Date;\r\n  name: string;\r\n  size: number;\r\n  type: string;\r\n  form: FormData;\r\n  progress: UploadProgress;\r\n  response?: any;\r\n  responseStatus?: number;\r\n  sub?: Subscription | any;\r\n  nativeFile?: File;\r\n  responseHeaders?: { [key: string]: string };\r\n}\r\n\r\nexport interface UploadOutput {\r\n  type: 'addedToQueue' | 'allAddedToQueue' | 'uploading' | 'done' | 'start' | 'cancelled' | 'dragOver'\r\n      | 'dragOut' | 'drop' | 'removed' | 'removedAll' | 'rejected';\r\n  file?: UploadFile;\r\n  nativeFile?: File;\r\n}\r\n\r\nexport interface UploadInput {\r\n  type: 'uploadAll' | 'uploadFile' | 'cancel' | 'cancelAll' | 'remove' | 'removeAll';\r\n  url?: string;\r\n  method?: string;\r\n  id?: string;\r\n  fieldName?: string;\r\n  fileIndex?: number;\r\n  file?: UploadFile;\r\n  data?: { [key: string]: string | Blob };\r\n  headers?: { [key: string]: string };\r\n  includeWebKitFormBoundary?: boolean; // If false, only the file is send trough xhr.send (WebKitFormBoundary is omit)\r\n  withCredentials?: boolean;\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { EventEmitter } from '@angular/core';\r\nimport { Observable, Subject, Subscription } from 'rxjs';\r\nimport { mergeMap, finalize } from 'rxjs/operators';\r\nimport { UploadFile, UploadOutput, UploadInput, UploadStatus, BlobFile } from './interfaces';\r\n\r\nexport function humanizeBytes(bytes: number): string {\r\n  if (bytes === 0) {\r\n    return '0 Byte';\r\n  }\r\n\r\n  const k = 1024;\r\n  const sizes: string[] = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\r\n  const i: number = Math.floor(Math.log(bytes) / Math.log(k));\r\n\r\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n}\r\n\r\nexport class NgUploaderService {\r\n  queue: UploadFile[];\r\n  serviceEvents: EventEmitter<UploadOutput>;\r\n  uploadScheduler: Subject<{ file: UploadFile; event: UploadInput }>;\r\n  subs: { id: string; sub: Subscription }[];\r\n  contentTypes: string[];\r\n  maxUploads: number;\r\n  maxFileSize: number;\r\n\r\n  constructor(\r\n    concurrency: number = Number.POSITIVE_INFINITY,\r\n    contentTypes: string[] = ['*'],\r\n    maxUploads: number = Number.POSITIVE_INFINITY,\r\n    maxFileSize: number = Number.POSITIVE_INFINITY\r\n  ) {\r\n    this.queue = [];\r\n    this.serviceEvents = new EventEmitter<UploadOutput>();\r\n    this.uploadScheduler = new Subject();\r\n    this.subs = [];\r\n    this.contentTypes = contentTypes;\r\n    this.maxUploads = maxUploads;\r\n    this.maxFileSize = maxFileSize;\r\n\r\n    this.uploadScheduler\r\n      .pipe(mergeMap(upload => this.startUpload(upload), concurrency))\r\n      .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\r\n  }\r\n\r\n  handleFiles(incomingFiles: FileList): void {\r\n    const allowedIncomingFiles: File[] = [].reduce.call(\r\n      incomingFiles,\r\n      (acc: File[], checkFile: File, i: number) => {\r\n        const futureQueueLength = acc.length + this.queue.length + 1;\r\n        if (\r\n          this.isContentTypeAllowed(checkFile.type) &&\r\n          futureQueueLength <= this.maxUploads &&\r\n          this.isFileSizeAllowed(checkFile.size)\r\n        ) {\r\n          acc = acc.concat(checkFile);\r\n        } else {\r\n          const rejectedFile: UploadFile = this.makeUploadFile(checkFile, i);\r\n          this.serviceEvents.emit({ type: 'rejected', file: rejectedFile });\r\n        }\r\n\r\n        return acc;\r\n      },\r\n      []\r\n    );\r\n\r\n    this.queue.push(\r\n      ...[].map.call(allowedIncomingFiles, (file: File, i: number) => {\r\n        const uploadFile: UploadFile = this.makeUploadFile(file, i);\r\n        this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });\r\n        return uploadFile;\r\n      })\r\n    );\r\n\r\n    this.serviceEvents.emit({ type: 'allAddedToQueue' });\r\n  }\r\n\r\n  initInputEvents(input: EventEmitter<UploadInput>): Subscription {\r\n    return input.subscribe((event: UploadInput) => {\r\n      switch (event.type) {\r\n        case 'uploadFile':\r\n          const uploadFileIndex = this.queue.findIndex(file => file === event.file);\r\n          if (uploadFileIndex !== -1 && event.file) {\r\n            this.uploadScheduler.next({ file: this.queue[uploadFileIndex], event: event });\r\n          }\r\n          break;\r\n        case 'uploadAll':\r\n          const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\r\n          files.forEach(file => this.uploadScheduler.next({ file: file, event: event }));\r\n          break;\r\n        case 'cancel':\r\n          const id = event.id || null;\r\n          if (!id) {\r\n            return;\r\n          }\r\n          const subs = this.subs.filter(sub => sub.id === id);\r\n          subs.forEach(sub => {\r\n            if (sub.sub) {\r\n              sub.sub.unsubscribe();\r\n              const fileIndex = this.queue.findIndex(file => file.id === id);\r\n              if (fileIndex !== -1) {\r\n                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\r\n                this.serviceEvents.emit({ type: 'cancelled', file: this.queue[fileIndex] });\r\n              }\r\n            }\r\n          });\r\n          break;\r\n        case 'cancelAll':\r\n          this.subs.forEach(sub => {\r\n            if (sub.sub) {\r\n              sub.sub.unsubscribe();\r\n            }\r\n\r\n            const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\r\n            if (file) {\r\n              file.progress.status = UploadStatus.Cancelled;\r\n              this.serviceEvents.emit({ type: 'cancelled', file: file });\r\n            }\r\n          });\r\n          break;\r\n        case 'remove':\r\n          if (!event.id) {\r\n            return;\r\n          }\r\n\r\n          const i = this.queue.findIndex(file => file.id === event.id);\r\n          if (i !== -1) {\r\n            const file = this.queue[i];\r\n            this.queue.splice(i, 1);\r\n            this.serviceEvents.emit({ type: 'removed', file: file });\r\n          }\r\n          break;\r\n        case 'removeAll':\r\n          if (this.queue.length) {\r\n            this.queue = [];\r\n            this.serviceEvents.emit({ type: 'removedAll' });\r\n          }\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  startUpload(upload: { file: UploadFile; event: UploadInput }): Observable<UploadOutput> {\r\n    return new Observable(observer => {\r\n      const sub = this.uploadFile(upload.file, upload.event)\r\n        .pipe(\r\n          finalize(() => {\r\n            if (!observer.closed) {\r\n              observer.complete();\r\n            }\r\n          })\r\n        )\r\n        .subscribe(\r\n          output => {\r\n            observer.next(output);\r\n          },\r\n          err => {\r\n            observer.error(err);\r\n            observer.complete();\r\n          },\r\n          () => {\r\n            observer.complete();\r\n          }\r\n        );\r\n\r\n      this.subs.push({ id: upload.file.id, sub: sub });\r\n    });\r\n  }\r\n\r\n  uploadFile(file: UploadFile, event: UploadInput): Observable<UploadOutput> {\r\n    return new Observable(observer => {\r\n      const url = event.url || '';\r\n      const method = event.method || 'POST';\r\n      const data = event.data || {};\r\n      const headers = event.headers || {};\r\n\r\n      const xhr = new XMLHttpRequest();\r\n      const time: number = new Date().getTime();\r\n      let progressStartTime: number = (file.progress.data && file.progress.data.startTime) || time;\r\n      let speed = 0;\r\n      let eta: number | null = null;\r\n\r\n      xhr.upload.addEventListener(\r\n        'progress',\r\n        (e: ProgressEvent) => {\r\n          if (e.lengthComputable) {\r\n            const percentage = Math.round((e.loaded * 100) / e.total);\r\n            const diff = new Date().getTime() - time;\r\n            speed = Math.round((e.loaded / diff) * 1000);\r\n            progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\r\n            eta = Math.ceil((e.total - e.loaded) / speed);\r\n\r\n            file.progress = {\r\n              status: UploadStatus.Uploading,\r\n              data: {\r\n                percentage: percentage,\r\n                speed: speed,\r\n                speedHuman: `${humanizeBytes(speed)}/s`,\r\n                startTime: progressStartTime,\r\n                endTime: null,\r\n                eta: eta,\r\n                etaHuman: this.secondsToHuman(eta)\r\n              }\r\n            };\r\n\r\n            observer.next({ type: 'uploading', file: file });\r\n          }\r\n        },\r\n        false\r\n      );\r\n\r\n      xhr.upload.addEventListener('error', (e: Event) => {\r\n        observer.error(e);\r\n        observer.complete();\r\n      });\r\n\r\n      xhr.onreadystatechange = () => {\r\n        if (xhr.readyState === XMLHttpRequest.DONE) {\r\n          const speedAverage = Math.round((file.size / (new Date().getTime() - progressStartTime)) * 1000);\r\n          file.progress = {\r\n            status: UploadStatus.Done,\r\n            data: {\r\n              percentage: 100,\r\n              speed: speedAverage,\r\n              speedHuman: `${humanizeBytes(speedAverage)}/s`,\r\n              startTime: progressStartTime,\r\n              endTime: new Date().getTime(),\r\n              eta: eta,\r\n              etaHuman: this.secondsToHuman(eta || 0)\r\n            }\r\n          };\r\n\r\n          file.responseStatus = xhr.status;\r\n\r\n          try {\r\n            file.response = JSON.parse(xhr.response);\r\n          } catch (e) {\r\n            file.response = xhr.response;\r\n          }\r\n\r\n          file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\r\n\r\n          observer.next({ type: 'done', file: file });\r\n\r\n          observer.complete();\r\n        }\r\n      };\r\n\r\n      xhr.open(method, url, true);\r\n      xhr.withCredentials = event.withCredentials ? true : false;\r\n\r\n      try {\r\n        const uploadFile = <BlobFile>file.nativeFile;\r\n        const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\r\n\r\n        if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\r\n          observer.complete();\r\n        }\r\n\r\n        Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\r\n\r\n        let bodyToSend: FormData | BlobFile;\r\n\r\n        if (event.includeWebKitFormBoundary !== false) {\r\n          Object.keys(data).forEach(key => file.form.append(key, data[key]));\r\n          file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\r\n          bodyToSend = file.form;\r\n        } else {\r\n          bodyToSend = uploadFile;\r\n        }\r\n\r\n        this.serviceEvents.emit({ type: 'start', file: file });\r\n        xhr.send(bodyToSend);\r\n      } catch (e) {\r\n        observer.complete();\r\n      }\r\n\r\n      return () => {\r\n        xhr.abort();\r\n      };\r\n    });\r\n  }\r\n\r\n  secondsToHuman(sec: number): string {\r\n    return new Date(sec * 1000).toISOString().substr(11, 8);\r\n  }\r\n\r\n  generateId(): string {\r\n    return Math.random().toString(36).substring(7);\r\n  }\r\n\r\n  setContentTypes(contentTypes: string[]): void {\r\n    if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\r\n      if (contentTypes.find((type: string) => type === '*') !== undefined) {\r\n        this.contentTypes = ['*'];\r\n      } else {\r\n        this.contentTypes = contentTypes;\r\n      }\r\n      return;\r\n    }\r\n    this.contentTypes = ['*'];\r\n  }\r\n\r\n  allContentTypesAllowed(): boolean {\r\n    return this.contentTypes.find((type: string) => type === '*') !== undefined;\r\n  }\r\n\r\n  isContentTypeAllowed(mimetype: string): boolean {\r\n    if (this.allContentTypesAllowed()) {\r\n      return true;\r\n    }\r\n    return this.contentTypes.find((type: string) => type === mimetype) !== undefined;\r\n  }\r\n\r\n  isFileSizeAllowed(fileSize: number): boolean {\r\n    if (!this.maxFileSize) {\r\n      return true;\r\n    }\r\n    return fileSize <= this.maxFileSize;\r\n  }\r\n\r\n  makeUploadFile(file: File, index: number): UploadFile {\r\n    return {\r\n      fileIndex: index,\r\n      id: this.generateId(),\r\n      name: file.name,\r\n      size: file.size,\r\n      type: file.type,\r\n      form: new FormData(),\r\n      progress: {\r\n        status: UploadStatus.Queue,\r\n        data: {\r\n          percentage: 0,\r\n          speed: 0,\r\n          speedHuman: `${humanizeBytes(0)}/s`,\r\n          startTime: null,\r\n          endTime: null,\r\n          eta: null,\r\n          etaHuman: null\r\n        }\r\n      },\r\n      lastModifiedDate: new Date(file.lastModified),\r\n      sub: undefined,\r\n      nativeFile: file\r\n    };\r\n  }\r\n\r\n  private parseResponseHeaders(httpHeaders: string): { [key: string]: string } {\r\n    if (!httpHeaders) {\r\n      return;\r\n    }\r\n\r\n    return httpHeaders\r\n      .split('\\n')\r\n      .map((x: string) => x.split(/: */, 2))\r\n      .filter((x: string[]) => x[0])\r\n      .reduce((acc: { [key: string]: string }, x: string[]) => {\r\n        acc[x[0]] = x[1];\r\n        return acc;\r\n      }, {});\r\n  }\r\n}\r\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy, HostListener } from '@angular/core';\r\nimport { UploadOutput, UploadInput, UploaderOptions } from './interfaces';\r\nimport { NgUploaderService } from './ngx-uploader.class';\r\nimport { Subscription } from 'rxjs';\r\n\r\n@Directive({\r\n  selector: '[ngFileDrop]'\r\n})\r\nexport class NgFileDropDirective implements OnInit, OnDestroy {\r\n  @Input() options: UploaderOptions;\r\n  @Input() uploadInput: EventEmitter<UploadInput>;\r\n  @Output() uploadOutput: EventEmitter<UploadOutput>;\r\n\r\n  upload: NgUploaderService;\r\n  el: HTMLInputElement;\r\n\r\n  _sub: Subscription[];\r\n\r\n  constructor(public elementRef: ElementRef) {\r\n    this.uploadOutput = new EventEmitter<UploadOutput>();\r\n  }\r\n\r\n  ngOnInit() {\r\n    this._sub = [];\r\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\r\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\r\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\r\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\r\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\r\n\r\n    this.el = this.elementRef.nativeElement;\r\n\r\n    this._sub.push(\r\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\r\n        this.uploadOutput.emit(event);\r\n      })\r\n    );\r\n\r\n    if (this.uploadInput instanceof EventEmitter) {\r\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\r\n    }\r\n\r\n    this.el.addEventListener('drop', this.stopEvent, false);\r\n    this.el.addEventListener('dragenter', this.stopEvent, false);\r\n    this.el.addEventListener('dragover', this.stopEvent, false);\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    this._sub.forEach(sub => sub.unsubscribe());\r\n  }\r\n\r\n  stopEvent = (e: Event) => {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n  }\r\n\r\n  @HostListener('drop', ['$event'])\r\n  public onDrop(e: any) {\r\n    e.stopPropagation();\r\n    e.preventDefault();\r\n\r\n    const event: UploadOutput = { type: 'drop' };\r\n    this.uploadOutput.emit(event);\r\n    this.upload.handleFiles(e.dataTransfer.files);\r\n  }\r\n\r\n  @HostListener('dragover', ['$event'])\r\n  public onDragOver(e: DragEvent) {\r\n    if (!e) {\r\n      return;\r\n    }\r\n    if (e && e.dataTransfer && e.dataTransfer.dropEffect != \"copy\") {\r\n\r\n      e.dataTransfer.dropEffect  = \"copy\";\r\n\r\n  }\r\n    const event: UploadOutput = { type: 'dragOver' };\r\n    this.uploadOutput.emit(event);\r\n  }\r\n\r\n  @HostListener('dragleave', ['$event'])\r\n  public onDragLeave(e: Event) {\r\n    if (!e) {\r\n      return;\r\n    }\r\n\r\n    const event: UploadOutput = { type: 'dragOut' };\r\n    this.uploadOutput.emit(event);\r\n  }\r\n}\r\n","import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy } from '@angular/core';\r\nimport { UploadOutput, UploaderOptions } from './interfaces';\r\nimport { NgUploaderService } from './ngx-uploader.class';\r\nimport { Subscription } from 'rxjs';\r\n\r\n@Directive({\r\n  selector: '[ngFileSelect]'\r\n})\r\nexport class NgFileSelectDirective implements OnInit, OnDestroy {\r\n  @Input() options: UploaderOptions;\r\n  @Input() uploadInput: EventEmitter<any>;\r\n  @Output() uploadOutput: EventEmitter<UploadOutput>;\r\n\r\n  upload: NgUploaderService;\r\n  el: HTMLInputElement;\r\n\r\n  _sub: Subscription[];\r\n\r\n  constructor(public elementRef: ElementRef) {\r\n    this.uploadOutput = new EventEmitter<UploadOutput>();\r\n  }\r\n\r\n  ngOnInit() {\r\n    this._sub = [];\r\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\r\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\r\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\r\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\r\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\r\n\r\n    this.el = this.elementRef.nativeElement;\r\n    this.el.addEventListener('change', this.fileListener, false);\r\n\r\n    this._sub.push(\r\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\r\n        this.uploadOutput.emit(event);\r\n      })\r\n    );\r\n\r\n    if (this.uploadInput instanceof EventEmitter) {\r\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\r\n    }\r\n  }\r\n\r\n  ngOnDestroy() {\r\n    if (this.el){\r\n      this.el.removeEventListener('change', this.fileListener, false);\r\n      this._sub.forEach(sub => sub.unsubscribe());\r\n    }\r\n  }\r\n\r\n  fileListener = () => {\r\n    if (this.el.files) {\r\n      this.upload.handleFiles(this.el.files);\r\n    }\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { NgFileDropDirective } from './ng-file-drop.directive';\r\nimport { NgFileSelectDirective } from './ng-file-select.directive';\r\n\r\n@NgModule({\r\n  declarations: [NgFileDropDirective, NgFileSelectDirective],\r\n  exports: [NgFileDropDirective, NgFileSelectDirective]\r\n})\r\nexport class NgxUploaderModule { }\r\n"]}